<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    function Person() {}
    var person = new Person();
    person.name = "Kevin";

    // prototype
    function Person() {}
    Person.prototype.name = "Kevin";
    var person1 = new Person();
    var person2 = new Person();
    console.log(person1.name); // Kevin
    console.log(person2.name); // Kevin

    // __proto__
    function Person() {}
    var person = new Person();
    console.log(person.__proto__ === Person.prototype); // true

    //constructor
    function Person() {}
    console.log(Person === Person.prototype.constructor); // true

    //综上所述
    function Person() {}
    var person = new Person();
    console.log(person.__proto__ == Person.prototype); // true
    console.log(Person.prototype.constructor == Person); // true
    //顺便学习一下ES5得方法,可以获得对象得原型
    console.log(Object.getPrototypeOf(person) === Person.prototype); // true

    //实例与原型
    function Person() {}
    Person.prototype.name = "Kevin";
    var person = new Person();
    person.name = "Daisy";
    console.log(person.name); // Daisy
    delete person.name;
    console.log(person.name); // Kevin

    //原型得原型
    var obj = new Object();
    (obj.name = "Kevin"), console.log(obj.name); //Kevin

    //原型链
    console.log(Object.prototype.__proto__ === null); //true
    // null 表示"没用对象" 即该处不应该有值

    // 补充
    function Person() {}
    var person = new Person();
    console.log(person.constructor === Person); // true
    //当获取person.constructor时，其实person中并没有constructor属性,当不能读取到constructor属性时,会从person的原型
    //也就是Person.prototype中读取时,正好原型中有该属性,所以
    person.constructor === Person.prototype.constructor;

    //__proto__
    //其次是__proto__，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于Person.prototype中，实际上，它
    // 是来自与Object.prototype,与其说是一个属性，不如说是一个getter/setter,当使用obj.__proto__时，可以理解成返回了
    // Object.getPrototypeOf(obj)

    /**
     *  总结：
     1、当一个对象查找属性和方法时会从自身查找,如果查找不到则会通过__proto__指向被实例化的构造函数的prototype
     2、隐式原型也是一个对象,是指向我们构造函数的原型
     3、除了最顶层的Object对象没有__proto_，其他所有的对象都有__proto__,这是隐式原型
     4、隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链
    */

    let fn = () => void console.log(111);
  </script>
</html>
